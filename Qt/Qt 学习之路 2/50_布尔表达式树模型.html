<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>布尔表达式树模型 - 《Qt 学习之路 2》 - 书栈网 · BookStack</title><meta name="keywords" content="书栈网,BookStack,Qt,GUI,Qt 5"/><meta name="description" content=" Qt 是一个著名的 C&#43;&#43; 应用程序框架。你并不能说它只是一个 GUI 库，因为 Qt 十分庞大，并不仅仅是 GUI 组件。使用 Qt，在一定程度上你获得的是一个“一站式”的解决方案：不再需要研究 STL，不再需要 C&#43;&#43; 的&lt;string&gt;，不再需要到处去找解析 XML、连接数据库、访问网络的各种第三方库，因为 Qt 自己内置了这些技术。"/><link href="https://static.sitestack.cn/static/bootstrap/css/bootstrap.min.css" rel="stylesheet"><link href="https://static.sitestack.cn/static/font-awesome/css/font-awesome.min.css" rel="stylesheet"><link href="https://static.sitestack.cn/static/nprogress/nprogress.css" rel="stylesheet"><link href="https://static.sitestack.cn/static/editor.md/css/editormd.preview.css" rel="stylesheet"><link href="https://static.sitestack.cn/static/css/toast.css" rel="stylesheet"><link rel="stylesheet" href="https://static.sitestack.cn/static/katex/katex.min.css"><link rel="stylesheet" href="https://static.sitestack.cn/static/mind-map/mindmap.css"><script src="https://static.sitestack.cn/static/html5shiv/3.7.3/html5shiv.min.js"></script><script src="https://static.sitestack.cn/static/respond.js/1.4.2/respond.min.js"></script><link href="https://static.sitestack.cn/static/css/bookstack.css?version=v2.11.beta1"rel="stylesheet"><style>
        .editormd-preview-container ol.linenums li code, .editormd-html-preview ol.linenums li code{
            display: block;
            white-space: pre;
        }
        li.L1, li.L3, li.L5, li.L7, li.L9{background-color: transparent;}
        .editormd-preview-container pre.prettyprint, .editormd-html-preview pre.prettyprint{border-color: transparent;}
        body{-webkit-overflow-scrolling:touch;}
        .alink,.alink a{color: #888 !important;}
        .alink:hover,.alink a:hover{color: red !important;}
    </style></head><body><div class="modal fade" id="ModalNote" tabindex="-1" role="dialog" aria-labelledby="ModalReplaceLabel"><div class="modal-dialog" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h1 class="modal-title" id="ModalReplaceLabel" style="align:center;">思维导图备注</h1></div><div class="modal-body" style="overflow-y:auto; height:400px;"></div><div class="modal-footer"><div class="modal-footer"><button type="button" class="btn btn-default" data-dismiss="modal">关闭</button></div></div></div></div></div><div class="m-manual manual-mode-view manual-reader"><header class="navbar navbar-static-top manual-head" role="banner"><div class="container-fluid"><div class="navbar-header pull-left manual-title"><span class="slidebar" id="slidebar"><i class="fa fa-align-justify"></i></span><a href="/books/qt-study-road-2" title="Qt 学习之路 2" class="book-title">Qt 学习之路 2</a><span style="font-size: 12px;font-weight: 100;"></span></div><div class="navbar-header pull-right manual-menu"><div class="bookstack-item"><a title="首页" href="/" class="btn btn-link"><i class="fa fa-home"></i> 首页</a><a title="BookChat 小程序" href="javascript:" data-toggle="modal" data-target="#ModalBookChat" class="btn btn-light"><img src="https://static.sitestack.cn/static/images/wxacode.png" style="position: relative;top:-2px;" alt="BookChat 小程序"><span>小程序</span></a><a title="下载" href="javascript:" data-toggle="modal" data-target="#ModalDownload" class="btn btn-light"><i class="fa fa-cloud-download"></i> 下载</a><a href="/record/2072" rel="nofollow" class="btn btn-link showModalHistory"><i class="fa fa-clock-o"></i> 阅读记录</a><span class="dropdown"><button class="btn btn-link dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">
                            书签管理 <span class="caret"></span></button><ul class="dropdown-menu" aria-labelledby="dropdownMenu1"><li><a rel="nofollow" href="/bookmark/list/2072" title="查看书签" rel="nofollow" data-bookid="2072" class="showModalBookmark"><img src="https://static.sitestack.cn/static/images/icon-bookmark-list.png" alt="书签"> 我的书签
                                </a></li><li><a href="/bookmark/" data-docid="114708" rel="nofollow" class="bookmark-action"><span class="bookmark-add "><img src="https://static.sitestack.cn/static/images/icon-bookmark-add.png" alt="添加书签"> 添加书签</span><span class="bookmark-remove hide"><img src="https://static.sitestack.cn/static/images/icon-bookmark-remove.png" alt="移除书签"> 移除书签</span></a></li></ul></span></div></div></div></header><div class="container-fluid manual-body"><div class="manual-right"><div class="manual-article"><div class="article-head"><div class="container-fluid"><div class="row"><div class="col-md-10 col-md-offset-1 col-xs-12 text-center"><h1 id="article-title">布尔表达式树模型</h1></div></div></div></div><div class="article-content"><div class="help-block article-info" style="padding-bottom: 20px;"><span><i class="fa fa-user-o"></i><a target="_blank" title="来源" href="https://www.devbean.net/2012/08/qt-study-road-2-catelog/">来源 豆子</a></span><span><i class="fa fa-eye"></i> 浏览 <i class="read-count">884</i></span><span class="hidden-xs"><a href="#" data-target="#ModalQRcode" data-toggle="modal"><i class="fa fa-qrcode"></i> 扫码</a></span><span><a href="#" data-target="#ModalShare" data-toggle="modal"><i class="fa fa-share-alt"></i> 分享</a></span><span class="pull-right hidden-xs tooltips" title="更新时间"><i class="fa fa-clock-o"></i><i class="updated-at">2019-05-26 14:43:23</i></span></div><article class="article-body  markdown-body editormd-preview-container"  id="page-content"><div class="markdown-toc editormd-markdown-toc"><ul class="markdown-toc-list"></ul></div><p>这个例子是将布尔表达式分析成一棵树。这个分析过程在离散数学中经常遇到，特别是复杂的布尔表达式。类似的分析方法可以套用于表达式化简、求值等一系列的运算。同时，这个技术也可以很方便地分析一个表达式是不是一个正确的布尔表达式。在这个例子中，一共有四个类：</p><ul><li><code>BooleanModel</code>：布尔表达式的模型，实际上这是一个树状模型，用于将布尔表达式形象地呈现为一棵树；</li><li><code>BooleanParser</code>：分析布尔表达式的分析器；</li><li><code>BooleanWindow</code>：图形用户界面，用户在此输入布尔表达式并进行分析，最后将结果展现成一棵树。<br/>首先，我们来看看最基础的<code>Node</code>类。这是分析树的节点，也是构成整棵树的基础。</li></ul><p><code>Node</code>的 cpp 文件也非常简单：</p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><span class="typ">Node</span><span class="pun">::</span><span class="typ">Node</span><span class="pun">(</span><span class="typ">Type</span><span class="pln"> type</span><span class="pun">,</span><span class="pln"></span><span class="kwd">const</span><span class="pln"></span><span class="typ">QString</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">str</span><span class="pun">)</span></li><li class="L1"><span class="pun">{</span></li><li class="L2"><span class="pln"></span><span class="kwd">this</span><span class="pun">-&gt;</span><span class="pln">type </span><span class="pun">=</span><span class="pln"> type</span><span class="pun">;</span></li><li class="L3"><span class="pln"></span><span class="kwd">this</span><span class="pun">-&gt;</span><span class="pln">str </span><span class="pun">=</span><span class="pln"> str</span><span class="pun">;</span></li><li class="L4"><span class="pln">    parent </span><span class="pun">=</span><span class="pln"></span><span class="lit">0</span><span class="pun">;</span></li><li class="L5"><span class="pun">}</span></li><li class="L6"><span class="pln"> </span></li><li class="L7"><span class="typ">Node</span><span class="pun">::~</span><span class="typ">Node</span><span class="pun">()</span></li><li class="L8"><span class="pun">{</span></li><li class="L9"><span class="pln">    qDeleteAll</span><span class="pun">(</span><span class="pln">children</span><span class="pun">);</span></li><li class="L0"><span class="pun">}</span></li></ol></pre><p><code>Node</code>很像一个典型的树的节点：一个<code>Node</code>指针类型的 parent 属性，保存父节点；一个<code>QString</code>类型的 str，保存数据。另外，<code>Node</code>还有一个<code>Type</code>属性，指明这个<code>Node</code>的类型，是一个词素，还是操作符，或者其他什么东西；<code>children</code>是<code>QList&lt;Node *&gt;</code>类型，保存这个 node 的所有子节点。注意，在 Node 类的析构函数中，使用了<code>qDeleteAll()</code>这个全局函数。这个函数是将 [start, end) 范围内的所有元素进行 delete 运算。因此，它的参数的元素必须是指针类型的。并且，这个函数使用 delete 之后并不会将指针赋值为 0，所以，如果要在析构函数之外调用这个函数，建议在调用之后显示的调用<code>clear()</code>函数，将列表所有元素的指针重置为 0。</p><p>虽然我们将这个例子放在自定义模型这部分，但实际上这个例子的核心类是<code>BooleanParser</code>。我们来看一下<code>BooleanParser</code>的代码：</p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><span class="com">// booleanparser.h</span></li><li class="L1"><span class="kwd">class</span><span class="pln"></span><span class="typ">BooleanParser</span></li><li class="L2"><span class="pun">{</span></li><li class="L3"><span class="kwd">public</span><span class="pun">:</span></li><li class="L4"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">parse</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QString</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">expr</span><span class="pun">);</span></li><li class="L5"><span class="pln"> </span></li><li class="L6"><span class="kwd">private</span><span class="pun">:</span></li><li class="L7"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">parseOrExpression</span><span class="pun">();</span></li><li class="L8"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">parseAndExpression</span><span class="pun">();</span></li><li class="L9"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">parseNotExpression</span><span class="pun">();</span></li><li class="L0"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">parseAtom</span><span class="pun">();</span></li><li class="L1"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">parseIdentifier</span><span class="pun">();</span></li><li class="L2"><span class="pln"></span><span class="kwd">void</span><span class="pln"> addChild</span><span class="pun">(</span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">parent</span><span class="pun">,</span><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">child</span><span class="pun">);</span></li><li class="L3"><span class="pln"></span><span class="kwd">void</span><span class="pln"> addToken</span><span class="pun">(</span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">parent</span><span class="pun">,</span><span class="pln"></span><span class="kwd">const</span><span class="pln"></span><span class="typ">QString</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">str</span><span class="pun">,</span><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Type</span><span class="pln"> type</span><span class="pun">);</span></li><li class="L4"><span class="pln"></span><span class="kwd">bool</span><span class="pln"> matchToken</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QString</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">str</span><span class="pun">)</span><span class="pln"></span><span class="kwd">const</span><span class="pun">;</span></li><li class="L5"><span class="pln"> </span></li><li class="L6"><span class="pln"></span><span class="typ">QString</span><span class="pln"></span><span class="kwd">in</span><span class="pun">;</span></li><li class="L7"><span class="pln"></span><span class="kwd">int</span><span class="pln"> pos</span><span class="pun">;</span></li><li class="L8"><span class="pun">};</span></li><li class="L9"><span class="pln"> </span></li><li class="L0"><span class="com">// booleanparser.cpp</span></li><li class="L1"><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="typ">BooleanParser</span><span class="pun">::</span><span class="pln">parse</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QString</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">expr</span><span class="pun">)</span></li><li class="L2"><span class="pun">{</span></li><li class="L3"><span class="pln"></span><span class="kwd">in</span><span class="pln"></span><span class="pun">=</span><span class="pln"> expr</span><span class="pun">;</span></li><li class="L4"><span class="pln"></span><span class="kwd">in</span><span class="pun">.</span><span class="pln">replace</span><span class="pun">(</span><span class="str">&#34; &#34;</span><span class="pun">,</span><span class="pln"></span><span class="str">&#34;&#34;</span><span class="pun">);</span></li><li class="L5"><span class="pln">    pos </span><span class="pun">=</span><span class="pln"></span><span class="lit">0</span><span class="pun">;</span></li><li class="L6"><span class="pln"> </span></li><li class="L7"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">node </span><span class="pun">=</span><span class="pln"></span><span class="kwd">new</span><span class="pln"></span><span class="typ">Node</span><span class="pun">(</span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Root</span><span class="pun">);</span></li><li class="L8"><span class="pln">    addChild</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"> parseOrExpression</span><span class="pun">());</span></li><li class="L9"><span class="pln"></span><span class="kwd">return</span><span class="pln"> node</span><span class="pun">;</span></li><li class="L0"><span class="pun">}</span></li><li class="L1"><span class="pln"> </span></li><li class="L2"><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="typ">BooleanParser</span><span class="pun">::</span><span class="pln">parseOrExpression</span><span class="pun">()</span></li><li class="L3"><span class="pun">{</span></li><li class="L4"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">childNode </span><span class="pun">=</span><span class="pln"> parseAndExpression</span><span class="pun">();</span></li><li class="L5"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(</span><span class="pln">matchToken</span><span class="pun">(</span><span class="str">&#34;||&#34;</span><span class="pun">))</span><span class="pln"></span><span class="pun">{</span></li><li class="L6"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">node </span><span class="pun">=</span><span class="pln"></span><span class="kwd">new</span><span class="pln"></span><span class="typ">Node</span><span class="pun">(</span><span class="typ">Node</span><span class="pun">::</span><span class="typ">OrExpression</span><span class="pun">);</span></li><li class="L7"><span class="pln">        addChild</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"> childNode</span><span class="pun">);</span></li><li class="L8"><span class="pln"></span><span class="kwd">while</span><span class="pln"></span><span class="pun">(</span><span class="pln">matchToken</span><span class="pun">(</span><span class="str">&#34;||&#34;</span><span class="pun">))</span><span class="pln"></span><span class="pun">{</span></li><li class="L9"><span class="pln">            addToken</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"></span><span class="str">&#34;||&#34;</span><span class="pun">,</span><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Operator</span><span class="pun">);</span></li><li class="L0"><span class="pln">            addChild</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"> parseAndExpression</span><span class="pun">());</span></li><li class="L1"><span class="pln"></span><span class="pun">}</span></li><li class="L2"><span class="pln"></span><span class="kwd">return</span><span class="pln"> node</span><span class="pun">;</span></li><li class="L3"><span class="pln"></span><span class="pun">}</span><span class="pln"></span><span class="kwd">else</span><span class="pln"></span><span class="pun">{</span></li><li class="L4"><span class="pln"></span><span class="kwd">return</span><span class="pln"> childNode</span><span class="pun">;</span></li><li class="L5"><span class="pln"></span><span class="pun">}</span></li><li class="L6"><span class="pun">}</span></li><li class="L7"><span class="pln"> </span></li><li class="L8"><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="typ">BooleanParser</span><span class="pun">::</span><span class="pln">parseAndExpression</span><span class="pun">()</span></li><li class="L9"><span class="pun">{</span></li><li class="L0"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">childNode </span><span class="pun">=</span><span class="pln"> parseNotExpression</span><span class="pun">();</span></li><li class="L1"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(</span><span class="pln">matchToken</span><span class="pun">(</span><span class="str">&#34;&amp;&amp;&#34;</span><span class="pun">))</span><span class="pln"></span><span class="pun">{</span></li><li class="L2"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">node </span><span class="pun">=</span><span class="pln"></span><span class="kwd">new</span><span class="pln"></span><span class="typ">Node</span><span class="pun">(</span><span class="typ">Node</span><span class="pun">::</span><span class="typ">AndExpression</span><span class="pun">);</span></li><li class="L3"><span class="pln">        addChild</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"> childNode</span><span class="pun">);</span></li><li class="L4"><span class="pln"></span><span class="kwd">while</span><span class="pln"></span><span class="pun">(</span><span class="pln">matchToken</span><span class="pun">(</span><span class="str">&#34;&amp;&amp;&#34;</span><span class="pun">))</span><span class="pln"></span><span class="pun">{</span></li><li class="L5"><span class="pln">            addToken</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"></span><span class="str">&#34;&amp;&amp;&#34;</span><span class="pun">,</span><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Operator</span><span class="pun">);</span></li><li class="L6"><span class="pln">            addChild</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"> parseNotExpression</span><span class="pun">());</span></li><li class="L7"><span class="pln"></span><span class="pun">}</span></li><li class="L8"><span class="pln"></span><span class="kwd">return</span><span class="pln"> node</span><span class="pun">;</span></li><li class="L9"><span class="pln"></span><span class="pun">}</span><span class="pln"></span><span class="kwd">else</span><span class="pln"></span><span class="pun">{</span></li><li class="L0"><span class="pln"></span><span class="kwd">return</span><span class="pln"> childNode</span><span class="pun">;</span></li><li class="L1"><span class="pln"></span><span class="pun">}</span></li><li class="L2"><span class="pun">}</span></li><li class="L3"><span class="pln"> </span></li><li class="L4"><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="typ">BooleanParser</span><span class="pun">::</span><span class="pln">parseNotExpression</span><span class="pun">()</span></li><li class="L5"><span class="pun">{</span></li><li class="L6"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(</span><span class="pln">matchToken</span><span class="pun">(</span><span class="str">&#34;!&#34;</span><span class="pun">))</span><span class="pln"></span><span class="pun">{</span></li><li class="L7"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">node </span><span class="pun">=</span><span class="pln"></span><span class="kwd">new</span><span class="pln"></span><span class="typ">Node</span><span class="pun">(</span><span class="typ">Node</span><span class="pun">::</span><span class="typ">NotExpression</span><span class="pun">);</span></li><li class="L8"><span class="pln"></span><span class="kwd">while</span><span class="pln"></span><span class="pun">(</span><span class="pln">matchToken</span><span class="pun">(</span><span class="str">&#34;!&#34;</span><span class="pun">))</span></li><li class="L9"><span class="pln">            addToken</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"></span><span class="str">&#34;!&#34;</span><span class="pun">,</span><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Operator</span><span class="pun">);</span></li><li class="L0"><span class="pln">        addChild</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"> parseAtom</span><span class="pun">());</span></li><li class="L1"><span class="pln"></span><span class="kwd">return</span><span class="pln"> node</span><span class="pun">;</span></li><li class="L2"><span class="pln"></span><span class="pun">}</span><span class="pln"></span><span class="kwd">else</span><span class="pln"></span><span class="pun">{</span></li><li class="L3"><span class="pln"></span><span class="kwd">return</span><span class="pln"> parseAtom</span><span class="pun">();</span></li><li class="L4"><span class="pln"></span><span class="pun">}</span></li><li class="L5"><span class="pun">}</span></li><li class="L6"><span class="pln"> </span></li><li class="L7"><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="typ">BooleanParser</span><span class="pun">::</span><span class="pln">parseAtom</span><span class="pun">()</span></li><li class="L8"><span class="pun">{</span></li><li class="L9"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(</span><span class="pln">matchToken</span><span class="pun">(</span><span class="str">&#34;(&#34;</span><span class="pun">))</span><span class="pln"></span><span class="pun">{</span></li><li class="L0"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">node </span><span class="pun">=</span><span class="pln"></span><span class="kwd">new</span><span class="pln"></span><span class="typ">Node</span><span class="pun">(</span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Atom</span><span class="pun">);</span></li><li class="L1"><span class="pln">        addToken</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"></span><span class="str">&#34;(&#34;</span><span class="pun">,</span><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Punctuator</span><span class="pun">);</span></li><li class="L2"><span class="pln">        addChild</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"> parseOrExpression</span><span class="pun">());</span></li><li class="L3"><span class="pln">        addToken</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"></span><span class="str">&#34;)&#34;</span><span class="pun">,</span><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Punctuator</span><span class="pun">);</span></li><li class="L4"><span class="pln"></span><span class="kwd">return</span><span class="pln"> node</span><span class="pun">;</span></li><li class="L6"><span class="pln"></span><span class="kwd">return</span><span class="pln"> parseIdentifier</span><span class="pun">();</span></li><li class="L7"><span class="pln"></span><span class="pun">}</span></li><li class="L8"><span class="pun">}</span></li><li class="L9"><span class="pln"> </span></li><li class="L0"><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="typ">BooleanParser</span><span class="pun">::</span><span class="pln">parseIdentifier</span><span class="pun">()</span></li><li class="L1"><span class="pun">{</span></li><li class="L2"><span class="pln"></span><span class="kwd">int</span><span class="pln"> startPos </span><span class="pun">=</span><span class="pln"> pos</span><span class="pun">;</span></li><li class="L3"><span class="pln"></span><span class="kwd">while</span><span class="pln"></span><span class="pun">(</span><span class="pln">pos </span><span class="pun">&lt;</span><span class="pln"></span><span class="kwd">in</span><span class="pun">.</span><span class="pln">length</span><span class="pun">()</span><span class="pln"></span><span class="pun">&amp;&amp;</span><span class="pln"></span><span class="kwd">in</span><span class="pun">[</span><span class="pln">pos</span><span class="pun">].</span><span class="pln">isLetterOrNumber</span><span class="pun">())</span></li><li class="L4"><span class="pln"></span><span class="pun">++</span><span class="pln">pos</span><span class="pun">;</span></li><li class="L5"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(</span><span class="pln">pos </span><span class="pun">&gt;</span><span class="pln"> startPos</span><span class="pun">)</span><span class="pln"></span><span class="pun">{</span></li><li class="L6"><span class="pln"></span><span class="kwd">return</span><span class="pln"></span><span class="kwd">new</span><span class="pln"></span><span class="typ">Node</span><span class="pun">(</span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Identifier</span><span class="pun">,</span></li><li class="L7"><span class="pln"></span><span class="kwd">in</span><span class="pun">.</span><span class="pln">mid</span><span class="pun">(</span><span class="pln">startPos</span><span class="pun">,</span><span class="pln"> pos </span><span class="pun">-</span><span class="pln"> startPos</span><span class="pun">));</span></li><li class="L8"><span class="pln"></span><span class="pun">}</span><span class="pln"></span><span class="kwd">else</span><span class="pln"></span><span class="pun">{</span></li><li class="L9"><span class="pln"></span><span class="kwd">return</span><span class="pln"></span><span class="lit">0</span><span class="pun">;</span></li><li class="L0"><span class="pln"></span><span class="pun">}</span></li><li class="L1"><span class="pun">}</span></li><li class="L2"><span class="pln"> </span></li><li class="L3"><span class="kwd">void</span><span class="pln"></span><span class="typ">BooleanParser</span><span class="pun">::</span><span class="pln">addChild</span><span class="pun">(</span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">parent</span><span class="pun">,</span><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">child</span><span class="pun">)</span></li><li class="L4"><span class="pun">{</span></li><li class="L5"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(</span><span class="pln">child</span><span class="pun">)</span><span class="pln"></span><span class="pun">{</span></li><li class="L6"><span class="pln">        parent</span><span class="pun">-&gt;</span><span class="pln">children </span><span class="pun">+=</span><span class="pln"> child</span><span class="pun">;</span></li><li class="L7"><span class="pln">        parent</span><span class="pun">-&gt;</span><span class="pln">str </span><span class="pun">+=</span><span class="pln"> child</span><span class="pun">-&gt;</span><span class="pln">str</span><span class="pun">;</span></li><li class="L8"><span class="pln">        child</span><span class="pun">-&gt;</span><span class="pln">parent </span><span class="pun">=</span><span class="pln"> parent</span><span class="pun">;</span></li><li class="L9"><span class="pln"></span><span class="pun">}</span></li><li class="L0"><span class="pun">}</span></li><li class="L1"><span class="pln"> </span></li><li class="L2"><span class="kwd">void</span><span class="pln"></span><span class="typ">BooleanParser</span><span class="pun">::</span><span class="pln">addToken</span><span class="pun">(</span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">parent</span><span class="pun">,</span><span class="pln"></span><span class="kwd">const</span><span class="pln"></span><span class="typ">QString</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">str</span><span class="pun">,</span></li><li class="L3"><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Type</span><span class="pln"> type</span><span class="pun">)</span></li><li class="L4"><span class="pun">{</span></li><li class="L5"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(</span><span class="kwd">in</span><span class="pun">.</span><span class="pln">mid</span><span class="pun">(</span><span class="pln">pos</span><span class="pun">,</span><span class="pln"> str</span><span class="pun">.</span><span class="pln">length</span><span class="pun">())</span><span class="pln"></span><span class="pun">==</span><span class="pln"> str</span><span class="pun">)</span><span class="pln"></span><span class="pun">{</span></li><li class="L6"><span class="pln">        addChild</span><span class="pun">(</span><span class="pln">parent</span><span class="pun">,</span><span class="pln"></span><span class="kwd">new</span><span class="pln"></span><span class="typ">Node</span><span class="pun">(</span><span class="pln">type</span><span class="pun">,</span><span class="pln"> str</span><span class="pun">));</span></li><li class="L7"><span class="pln">        pos </span><span class="pun">+=</span><span class="pln"> str</span><span class="pun">.</span><span class="pln">length</span><span class="pun">();</span></li><li class="L8"><span class="pln"></span><span class="pun">}</span></li><li class="L9"><span class="pun">}</span></li><li class="L0"><span class="pln"> </span></li><li class="L1"><span class="kwd">bool</span><span class="pln"></span><span class="typ">BooleanParser</span><span class="pun">::</span><span class="pln">matchToken</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QString</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">str</span><span class="pun">)</span><span class="pln"></span><span class="kwd">const</span></li><li class="L2"><span class="pun">{</span></li><li class="L3"><span class="pln"></span><span class="kwd">return</span><span class="pln"></span><span class="kwd">in</span><span class="pun">.</span><span class="pln">mid</span><span class="pun">(</span><span class="pln">pos</span><span class="pun">,</span><span class="pln"> str</span><span class="pun">.</span><span class="pln">length</span><span class="pun">())</span><span class="pln"></span><span class="pun">==</span><span class="pln"> str</span><span class="pun">;</span></li><li class="L4"><span class="pun">}</span></li></ol></pre><p>这里我们一次把<code>BooleanParser</code>的所有代码全部列了出来。我们首先从轮廓上面来看一下，<code>BooleanParser</code>作为核心类，并没有掺杂有关界面的任何代码。这是我们提出这个例子的另外一个重要原因：分层。对于初学者而言，如何设计好一个项目至关重要。分层就是其中一个重要的设计手法。或许你已经明白了 MVC 架构的基本概念，在这里也不再赘述。简单提一句，所谓分层，就是将程序的不同部分完全分离。比如这里的<code>BooleanParser</code> 类，仅仅是处理<code>Node</code>的节点，然后返回处理结果，至于处理结果如何显示，<code>BooleanParser</code>不去关心。通过前面我们了解到的 model/view 的相关知识也可以看出，这样做的好处是，今天我们可以使用 来显示这个结果，明天我发现图形界面不大合适，我想换用字符界面显示——没问题，只需要替换掉用于显示的部分就可以了。</p><p>大致了解了<code>BooleanParser</code>的总体设计思路（也就是从显示逻辑完全剥离开来）后，我们详细看看这个类的业务逻辑，也就是算法。虽然算法不是我们这里的重点，但是针对一个示例而言，这个算法是最核心的部分，并且体现了一类典型的算法，豆子觉得还是有必要了解下。</p><p>注意到<code>BooleanParser</code> 类只有一个公共函数，显然我们必须从这里着手来理解这个算法。在<code>Node * parse(const QString &amp;)</code>函数中，首先将传入的布尔表达式的字符串保存下来，避免直接修改参数（这也是库的接口设计中常见的一个原则：不修改参数）；然后我们将其中的空格全部去掉，并将 pos 设为 0。pos 就是我们在分析布尔表达式字符串时的当前字符位置，起始为 0。之后我们创建了 Root 节点——布尔表达式的树状表达，显然需要有一个根节点，所以我们在这里直接创建根节点，这个根节点就是一个完整的布尔表达式。</p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><span class="pln">BE</span><span class="pun">→</span><span class="pln"> BE OR BE</span></li><li class="L1"><span class="pln"></span><span class="pun">|</span><span class="pln"> BE AND BE</span></li><li class="L2"><span class="pln"></span><span class="pun">|</span><span class="pln"> NOT BE</span></li><li class="L3"><span class="pln"></span><span class="pun">|</span><span class="pln"></span><span class="pun">(</span><span class="pln">BE</span><span class="pun">)</span></li><li class="L4"><span class="pln"></span><span class="pun">|</span><span class="pln"> RE </span><span class="pun">|</span><span class="pln"></span><span class="kwd">true</span><span class="pln"></span><span class="pun">|</span><span class="pln"></span><span class="kwd">false</span></li><li class="L5"><span class="pln">RE</span><span class="pun">→</span><span class="pln"> RE RELOP RE </span><span class="pun">|</span><span class="pln"></span><span class="pun">(</span><span class="pln">RE</span><span class="pun">)</span><span class="pln"></span><span class="pun">|</span><span class="pln"> E</span></li><li class="L6"><span class="pln">E </span><span class="pun">→</span><span class="pln"> E op E </span><span class="pun">|</span><span class="pln"></span><span class="pun">-</span><span class="pln">E </span><span class="pun">|</span><span class="pln"></span><span class="pun">(</span><span class="pln">E</span><span class="pun">)</span><span class="pln"></span><span class="pun">|</span><span class="pln"></span><span class="typ">Identifier</span><span class="pln"></span><span class="pun">|</span><span class="pln"></span><span class="typ">Number</span></li></ol></pre><p>这是一个相对比较完整的布尔表达式文法。这里我们只使用其中一部分：</p><p>从我们简化的文法可以看出，布尔表达式 BE 可以由 BE | BE、BE AND BE、NOT BE、(BE) 和 Identifier 五部分组成，而每一部分都可以再递归地由 BE 进行定义。</p><p>接下来看算法的真正核心：我们按照上述文法来展开算法。要处理一个布尔表达式，或运算的优先级是最低，应该最后被处理。一旦或运算处理完毕，意味着整个布尔表达式已经处理完毕，所以我们在调用了 <code>addChild(node, parseOrExpression())</code>之后，返回整个 node。下面来看<code>parseOrExpression()</code>函数。要想处理 OR 运算，首先要处理 AND 运算，于是<code>parseOrExpression()</code>函数的第一句，我们调用了<code>parseAndExpression()</code>函数。要想处理 AND 运算，首先要处理 NOT 运算，于是<code>parseAndExpression()</code>的第一句，我们调用了<code>parseNotExpression()</code>函数。在<code>parseNotExpression()</code>函数中，检查第一个字符是不是 !，如果是，意味着这个表达式是一个 NOT 运算，生成 NOT 节点。NOT 节点可能会有两种不同的情况：</p><ul><li>子表达式（也就是用括号包围起来的部分，由于这部分的优先级最高，所以看做是一个完整的子表达式），子表达式是原子性的，需要一个独立的处理，也要生成一个节点，其分隔符是 ( 和 )。( 和 ) 之间又是一个完整的布尔表达式，回忆一下，一个完整的布尔表达式最后要处理的部分是 OR 运算，因此调用<code>parseOrExpression()</code>函数进行递归。</li><li>标识符（如果 ! 符号后面不是 ( 和 )，则只能是一个标识符，这是布尔表达式文法决定的），我们使用<code>parseIdentifier()</code>函数来获得这个标识符。这个函数很简单：从 pos 位置开始一个个检查当前字符是不是字母，如果是，说明这个字符是标识符的一部分，如果不是，说明标识符已经在上一个字符的位置结束（注意，是<strong>上一个字符</strong>的位置，而不是当前字符，当检测到当前字符不是字母时，说明标识符已经在上一个字母那里结束了，当前字母不属于标识符的一部分），我们截取 startPos 开始，pos – startPos 长度的字符串作为标识符名称，而不是 pos – startPos + 1 长度。<br/>NOT 节点处理完毕，函数返回到<code>parseAndExpression()</code>。如果 NOT 节点后面是 &amp;&amp;，说明是 AND 节点。我们生成一个 AND 节点，把刚刚处理过的 NOT 节点添加为其子节点，如果一直找到了 &amp;&amp; 符号，就要一直作为 AND 节点处理，直到找到的不是 &amp;&amp;，AND 节点处理完毕，返回这个 node。另一方面，如果 NOT 节点后面不是 &amp;&amp;，说明根本不是 AND 节点，则直接把刚刚处理过的 NOT 节点返回。函数重新回到 parseOrExpression() 这里。此时需要检查是不是 ||，其过程同 &amp;&amp; 类型，这里不再赘述。</li></ul><p>这个过程看起来非常复杂，实际非常清晰：一层一层按照文法递归执行，从最顶层一直到最底层。如果把有限自动机图示画出来，这个过程非常简洁明了。这就是编译原理的词法分析中最重要的算法之一：<strong>递归下降算法</strong>。由于这个算法简洁明了，很多编译器的词法分析都是使用的这个算法（当然，其性能有待商榷，所以成熟的编译器很可能选择了其它性能更好的算法）。最后，如果你觉得对这部分理解困难，不妨跳过，原本有关编译原理的内容都比较复杂。</p><p>最复杂的算法已经完成，接下来是<code>BooleanModel</code> 类：</p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><span class="kwd">class</span><span class="pln"></span><span class="typ">BooleanModel</span><span class="pln"></span><span class="pun">:</span><span class="pln"></span><span class="kwd">public</span><span class="pln"></span><span class="typ">QAbstractItemModel</span></li><li class="L1"><span class="pun">{</span></li><li class="L2"><span class="kwd">public</span><span class="pun">:</span></li><li class="L3"><span class="pln"></span><span class="typ">BooleanModel</span><span class="pun">(</span><span class="typ">QObject</span><span class="pln"></span><span class="pun">*</span><span class="pln">parent </span><span class="pun">=</span><span class="pln"></span><span class="lit">0</span><span class="pun">);</span></li><li class="L4"><span class="pln"></span><span class="pun">~</span><span class="typ">BooleanModel</span><span class="pun">();</span></li><li class="L5"><span class="pln"> </span></li><li class="L6"><span class="pln"></span><span class="kwd">void</span><span class="pln"> setRootNode</span><span class="pun">(</span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">node</span><span class="pun">);</span></li><li class="L7"><span class="pln"> </span></li><li class="L8"><span class="pln"></span><span class="typ">QModelIndex</span><span class="pln"> index</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> row</span><span class="pun">,</span><span class="pln"></span><span class="kwd">int</span><span class="pln"> column</span><span class="pun">,</span></li><li class="L9"><span class="pln"></span><span class="kwd">const</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">parent</span><span class="pun">)</span><span class="pln"></span><span class="kwd">const</span><span class="pun">;</span></li><li class="L0"><span class="pln"></span><span class="typ">QModelIndex</span><span class="pln"> parent</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">child</span><span class="pun">)</span><span class="pln"></span><span class="kwd">const</span><span class="pun">;</span></li><li class="L1"><span class="pln"> </span></li><li class="L2"><span class="pln"></span><span class="kwd">int</span><span class="pln"> rowCount</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">parent</span><span class="pun">)</span><span class="pln"></span><span class="kwd">const</span><span class="pun">;</span></li><li class="L3"><span class="pln"></span><span class="kwd">int</span><span class="pln"> columnCount</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">parent</span><span class="pun">)</span><span class="pln"></span><span class="kwd">const</span><span class="pun">;</span></li><li class="L4"><span class="pln"></span><span class="typ">QVariant</span><span class="pln"> data</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">index</span><span class="pun">,</span><span class="pln"></span><span class="kwd">int</span><span class="pln"> role</span><span class="pun">)</span><span class="pln"></span><span class="kwd">const</span><span class="pun">;</span></li><li class="L5"><span class="pln"></span><span class="typ">QVariant</span><span class="pln"> headerData</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> section</span><span class="pun">,</span><span class="pln"></span><span class="typ">Qt</span><span class="pun">::</span><span class="typ">Orientation</span><span class="pln"> orientation</span><span class="pun">,</span></li><li class="L6"><span class="pln"></span><span class="kwd">int</span><span class="pln"> role</span><span class="pun">)</span><span class="pln"></span><span class="kwd">const</span><span class="pun">;</span></li><li class="L7"><span class="pln"> </span></li><li class="L8"><span class="kwd">private</span><span class="pun">:</span></li><li class="L9"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">nodeFromIndex</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">index</span><span class="pun">)</span><span class="pln"></span><span class="kwd">const</span><span class="pun">;</span></li><li class="L0"><span class="pln"> </span></li><li class="L1"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">rootNode</span><span class="pun">;</span></li><li class="L2"><span class="pun">};</span></li></ol></pre><p><code>BooleanModel</code>类继承了<code>QAbstractItemModel</code>。之所以不继承<code>QAbstractListModel</code>或者<code>QAbstractTableModel</code>，是因为我们要构造一个带有层次结构的模型。在构造函数中，我们把根节点的指针赋值为 0，因此我们提供了另外的一个函数<code>setRootNode()</code>，将根节点进行有效地赋值。而在析构中，我们直接使用 delete 操作符将这个根节点释放掉。在<code>setRootNode()</code>函数中，首先我们释放原有的根节点，再将根节点赋值。此时我们需要通知所有视图对界面进行重绘，以表现最新的数据：</p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><span class="typ">BooleanModel</span><span class="pun">::</span><span class="typ">BooleanModel</span><span class="pun">(</span><span class="typ">QObject</span><span class="pln"></span><span class="pun">*</span><span class="pln">parent</span><span class="pun">)</span></li><li class="L1"><span class="pln"></span><span class="pun">:</span><span class="pln"></span><span class="typ">QAbstractItemModel</span><span class="pun">(</span><span class="pln">parent</span><span class="pun">)</span></li><li class="L2"><span class="pun">{</span></li><li class="L3"><span class="pln">    rootNode </span><span class="pun">=</span><span class="pln"></span><span class="lit">0</span><span class="pun">;</span></li><li class="L4"><span class="pun">}</span></li><li class="L5"><span class="pln"> </span></li><li class="L6"><span class="typ">BooleanModel</span><span class="pun">::~</span><span class="typ">BooleanModel</span><span class="pun">()</span></li><li class="L7"><span class="pun">{</span></li><li class="L8"><span class="pln"></span><span class="kwd">delete</span><span class="pln"> rootNode</span><span class="pun">;</span></li><li class="L9"><span class="pun">}</span></li><li class="L0"><span class="pln"> </span></li><li class="L1"><span class="kwd">void</span><span class="pln"></span><span class="typ">BooleanModel</span><span class="pun">::</span><span class="pln">setRootNode</span><span class="pun">(</span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">node</span><span class="pun">)</span></li><li class="L2"><span class="pun">{</span></li><li class="L3"><span class="pln">    beginResetModel</span><span class="pun">();</span></li><li class="L4"><span class="pln"></span><span class="kwd">delete</span><span class="pln"> rootNode</span><span class="pun">;</span></li><li class="L5"><span class="pln">    rootNode </span><span class="pun">=</span><span class="pln"> node</span><span class="pun">;</span></li><li class="L6"><span class="pln">    endResetModel</span><span class="pun">();</span></li><li class="L7"><span class="pun">}</span></li></ol></pre><p>直接继承<code>QAbstractItemModel</code>类，我们必须实现它的五个纯虚函数。首先是<code>index()</code>函数。这个函数在或者<code>QAbstractListModel</code>中不需要实现，因此那两个类已经实现过了。但是，因为我们现在继承的<code>QAbstractItemModel</code>，必须提供一个合适的实现：</p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><span class="typ">QModelIndex</span><span class="pln"></span><span class="typ">BooleanModel</span><span class="pun">::</span><span class="pln">index</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> row</span><span class="pun">,</span><span class="pln"></span><span class="kwd">int</span><span class="pln"> column</span><span class="pun">,</span></li><li class="L1"><span class="pln"></span><span class="kwd">const</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">parent</span><span class="pun">)</span><span class="pln"></span><span class="kwd">const</span></li><li class="L2"><span class="pun">{</span></li><li class="L3"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(!</span><span class="pln">rootNode </span><span class="pun">||</span><span class="pln"> row </span><span class="pun">&lt;</span><span class="pln"></span><span class="lit">0</span><span class="pln"></span><span class="pun">||</span><span class="pln"> column </span><span class="pun">&lt;</span><span class="pln"></span><span class="lit">0</span><span class="pun">)</span></li><li class="L4"><span class="pln"></span><span class="kwd">return</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pun">();</span></li><li class="L5"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">parentNode </span><span class="pun">=</span><span class="pln"> nodeFromIndex</span><span class="pun">(</span><span class="pln">parent</span><span class="pun">);</span></li><li class="L6"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">childNode </span><span class="pun">=</span><span class="pln"> parentNode</span><span class="pun">-&gt;</span><span class="pln">children</span><span class="pun">.</span><span class="pln">value</span><span class="pun">(</span><span class="pln">row</span><span class="pun">);</span></li><li class="L7"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(!</span><span class="pln">childNode</span><span class="pun">)</span></li><li class="L8"><span class="pln"></span><span class="kwd">return</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pun">();</span></li><li class="L9"><span class="pln"></span><span class="kwd">return</span><span class="pln"> createIndex</span><span class="pun">(</span><span class="pln">row</span><span class="pun">,</span><span class="pln"> column</span><span class="pun">,</span><span class="pln"> childNode</span><span class="pun">);</span></li></ol></pre><p><code>rowCount()</code>和<code>columnCount()</code>两个函数相对简单：</p><p>对于<code>rowCount()</code>，显然返回的是 parentNode 的子节点的数目；对于<code>columnCount()</code>，由于我们界面分为两列，所以始终返回 2。</p><p><code>parent()</code>函数返回子节点所属的父节点的索引。我们需要从子节点开始寻找，直到找到其父节点的父节点，这样才能定位到这个父节点，从而得到子节点的位置。而<code>data()</code>函数则要返回每个单元格的显示值。在前面两章的基础之上，我们应该可以很容易地理解这两个函数的内容。函数返回列头的名字，同前面一样，这里就不再赘述了：</p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><span class="typ">QModelIndex</span><span class="pln"></span><span class="typ">BooleanModel</span><span class="pun">::</span><span class="pln">parent</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">child</span><span class="pun">)</span><span class="pln"></span><span class="kwd">const</span></li><li class="L1"><span class="pun">{</span></li><li class="L2"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">node </span><span class="pun">=</span><span class="pln"> nodeFromIndex</span><span class="pun">(</span><span class="pln">child</span><span class="pun">);</span></li><li class="L3"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(!</span><span class="pln">node</span><span class="pun">)</span></li><li class="L4"><span class="pln"></span><span class="kwd">return</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pun">();</span></li><li class="L5"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">parentNode </span><span class="pun">=</span><span class="pln"> node</span><span class="pun">-&gt;</span><span class="pln">parent</span><span class="pun">;</span></li><li class="L6"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(!</span><span class="pln">parentNode</span><span class="pun">)</span></li><li class="L7"><span class="pln"></span><span class="kwd">return</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pun">();</span></li><li class="L8"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">grandparentNode </span><span class="pun">=</span><span class="pln"> parentNode</span><span class="pun">-&gt;</span><span class="pln">parent</span><span class="pun">;</span></li><li class="L9"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(!</span><span class="pln">grandparentNode</span><span class="pun">)</span></li><li class="L0"><span class="pln"></span><span class="kwd">return</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pun">();</span></li><li class="L1"><span class="pln"> </span></li><li class="L2"><span class="pln"></span><span class="kwd">int</span><span class="pln"> row </span><span class="pun">=</span><span class="pln"> grandparentNode</span><span class="pun">-&gt;</span><span class="pln">children</span><span class="pun">.</span><span class="pln">indexOf</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">);</span></li><li class="L3"><span class="pln"></span><span class="kwd">return</span><span class="pln"> createIndex</span><span class="pun">(</span><span class="pln">row</span><span class="pun">,</span><span class="pln"></span><span class="lit">0</span><span class="pun">,</span><span class="pln"> parentNode</span><span class="pun">);</span></li><li class="L4"><span class="pun">}</span></li><li class="L5"><span class="pln"> </span></li><li class="L6"><span class="typ">QVariant</span><span class="pln"></span><span class="typ">BooleanModel</span><span class="pun">::</span><span class="pln">data</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">index</span><span class="pun">,</span><span class="pln"></span><span class="kwd">int</span><span class="pln"> role</span><span class="pun">)</span><span class="pln"></span><span class="kwd">const</span></li><li class="L7"><span class="pun">{</span></li><li class="L8"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(</span><span class="pln">role </span><span class="pun">!=</span><span class="pln"></span><span class="typ">Qt</span><span class="pun">::</span><span class="typ">DisplayRole</span><span class="pun">)</span></li><li class="L9"><span class="pln"></span><span class="kwd">return</span><span class="pln"></span><span class="typ">QVariant</span><span class="pun">();</span></li><li class="L0"><span class="pln"> </span></li><li class="L1"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">node </span><span class="pun">=</span><span class="pln"> nodeFromIndex</span><span class="pun">(</span><span class="pln">index</span><span class="pun">);</span></li><li class="L2"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(!</span><span class="pln">node</span><span class="pun">)</span></li><li class="L3"><span class="pln"></span><span class="kwd">return</span><span class="pln"></span><span class="typ">QVariant</span><span class="pun">();</span></li><li class="L4"><span class="pln"> </span></li><li class="L5"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(</span><span class="pln">index</span><span class="pun">.</span><span class="pln">column</span><span class="pun">()</span><span class="pln"></span><span class="pun">==</span><span class="pln"></span><span class="lit">0</span><span class="pun">)</span><span class="pln"></span><span class="pun">{</span></li><li class="L6"><span class="pln"></span><span class="kwd">switch</span><span class="pln"></span><span class="pun">(</span><span class="pln">node</span><span class="pun">-&gt;</span><span class="pln">type</span><span class="pun">)</span><span class="pln"></span><span class="pun">{</span></li><li class="L7"><span class="pln"></span><span class="kwd">case</span><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Root</span><span class="pun">:</span></li><li class="L8"><span class="pln"></span><span class="kwd">return</span><span class="pln"> tr</span><span class="pun">(</span><span class="str">&#34;Root&#34;</span><span class="pun">);</span></li><li class="L9"><span class="pln"></span><span class="kwd">case</span><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">OrExpression</span><span class="pun">:</span></li><li class="L0"><span class="pln"></span><span class="kwd">return</span><span class="pln"> tr</span><span class="pun">(</span><span class="str">&#34;OR Expression&#34;</span><span class="pun">);</span></li><li class="L1"><span class="pln"></span><span class="kwd">case</span><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">AndExpression</span><span class="pun">:</span></li><li class="L2"><span class="pln"></span><span class="kwd">return</span><span class="pln"> tr</span><span class="pun">(</span><span class="str">&#34;AND Expression&#34;</span><span class="pun">);</span></li><li class="L3"><span class="pln"></span><span class="kwd">case</span><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">NotExpression</span><span class="pun">:</span></li><li class="L4"><span class="pln"></span><span class="kwd">return</span><span class="pln"> tr</span><span class="pun">(</span><span class="str">&#34;NOT Expression&#34;</span><span class="pun">);</span></li><li class="L5"><span class="pln"></span><span class="kwd">case</span><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Atom</span><span class="pun">:</span></li><li class="L6"><span class="pln"></span><span class="kwd">return</span><span class="pln"> tr</span><span class="pun">(</span><span class="str">&#34;Atom&#34;</span><span class="pun">);</span></li><li class="L7"><span class="pln"></span><span class="kwd">case</span><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Identifier</span><span class="pun">:</span></li><li class="L8"><span class="pln"></span><span class="kwd">return</span><span class="pln"> tr</span><span class="pun">(</span><span class="str">&#34;Identifier&#34;</span><span class="pun">);</span></li><li class="L9"><span class="pln"></span><span class="kwd">case</span><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Operator</span><span class="pun">:</span></li><li class="L0"><span class="pln"></span><span class="kwd">return</span><span class="pln"> tr</span><span class="pun">(</span><span class="str">&#34;Operator&#34;</span><span class="pun">);</span></li><li class="L1"><span class="pln"></span><span class="kwd">case</span><span class="pln"></span><span class="typ">Node</span><span class="pun">::</span><span class="typ">Punctuator</span><span class="pun">:</span></li><li class="L2"><span class="pln"></span><span class="kwd">return</span><span class="pln"> tr</span><span class="pun">(</span><span class="str">&#34;Punctuator&#34;</span><span class="pun">);</span></li><li class="L3"><span class="pln"></span><span class="kwd">default</span><span class="pun">:</span></li><li class="L4"><span class="pln"></span><span class="kwd">return</span><span class="pln"> tr</span><span class="pun">(</span><span class="str">&#34;Unknown&#34;</span><span class="pun">);</span></li><li class="L5"><span class="pln"></span><span class="pun">}</span></li><li class="L6"><span class="pln"></span><span class="pun">}</span><span class="pln"></span><span class="kwd">else</span><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(</span><span class="pln">index</span><span class="pun">.</span><span class="pln">column</span><span class="pun">()</span><span class="pln"></span><span class="pun">==</span><span class="pln"></span><span class="lit">1</span><span class="pun">)</span><span class="pln"></span><span class="pun">{</span></li><li class="L7"><span class="pln"></span><span class="kwd">return</span><span class="pln"> node</span><span class="pun">-&gt;</span><span class="pln">str</span><span class="pun">;</span></li><li class="L8"><span class="pln"></span><span class="pun">}</span></li><li class="L9"><span class="pln"></span><span class="kwd">return</span><span class="pln"></span><span class="typ">QVariant</span><span class="pun">();</span></li><li class="L0"><span class="pun">}</span></li><li class="L1"><span class="pln"> </span></li><li class="L2"><span class="typ">QVariant</span><span class="pln"></span><span class="typ">BooleanModel</span><span class="pun">::</span><span class="pln">headerData</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> section</span><span class="pun">,</span></li><li class="L3"><span class="pln"></span><span class="typ">Qt</span><span class="pun">::</span><span class="typ">Orientation</span><span class="pln"> orientation</span><span class="pun">,</span></li><li class="L4"><span class="pln"></span><span class="kwd">int</span><span class="pln"> role</span><span class="pun">)</span><span class="pln"></span><span class="kwd">const</span></li><li class="L5"><span class="pun">{</span></li><li class="L6"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(</span><span class="pln">orientation </span><span class="pun">==</span><span class="pln"></span><span class="typ">Qt</span><span class="pun">::</span><span class="typ">Horizontal</span><span class="pln"></span><span class="pun">&amp;&amp;</span><span class="pln"> role </span><span class="pun">==</span><span class="pln"></span><span class="typ">Qt</span><span class="pun">::</span><span class="typ">DisplayRole</span><span class="pun">)</span><span class="pln"></span><span class="pun">{</span></li><li class="L7"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(</span><span class="pln">section </span><span class="pun">==</span><span class="pln"></span><span class="lit">0</span><span class="pun">)</span><span class="pln"></span><span class="pun">{</span></li><li class="L8"><span class="pln"></span><span class="kwd">return</span><span class="pln"> tr</span><span class="pun">(</span><span class="str">&#34;Node&#34;</span><span class="pun">);</span></li><li class="L9"><span class="pln"></span><span class="pun">}</span><span class="pln"></span><span class="kwd">else</span><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(</span><span class="pln">section </span><span class="pun">==</span><span class="pln"></span><span class="lit">1</span><span class="pun">)</span><span class="pln"></span><span class="pun">{</span></li><li class="L0"><span class="pln"></span><span class="kwd">return</span><span class="pln"> tr</span><span class="pun">(</span><span class="str">&#34;Value&#34;</span><span class="pun">);</span></li><li class="L1"><span class="pln"></span><span class="pun">}</span></li><li class="L2"><span class="pln"></span><span class="pun">}</span></li><li class="L3"><span class="pln"></span><span class="kwd">return</span><span class="pln"></span><span class="typ">QVariant</span><span class="pun">();</span></li><li class="L4"><span class="pun">}</span></li></ol></pre><p>最后是我们定义的一个辅助函数：</p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="typ">BooleanModel</span><span class="pun">::</span><span class="pln">nodeFromIndex</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QModelIndex</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">index</span><span class="pun">)</span><span class="pln"></span><span class="kwd">const</span></li><li class="L1"><span class="pun">{</span></li><li class="L2"><span class="pln"></span><span class="kwd">if</span><span class="pln"></span><span class="pun">(</span><span class="pln">index</span><span class="pun">.</span><span class="pln">isValid</span><span class="pun">())</span><span class="pln"></span><span class="pun">{</span></li><li class="L3"><span class="pln"></span><span class="kwd">return</span><span class="pln"></span><span class="kwd">static_cast</span><span class="pun">&lt;</span><span class="typ">Node</span><span class="pln"></span><span class="pun">*&gt;(</span><span class="pln">index</span><span class="pun">.</span><span class="pln">internalPointer</span><span class="pun">());</span></li><li class="L4"><span class="pln"></span><span class="pun">}</span><span class="pln"></span><span class="kwd">else</span><span class="pln"></span><span class="pun">{</span></li><li class="L5"><span class="pln"></span><span class="kwd">return</span><span class="pln"> rootNode</span><span class="pun">;</span></li><li class="L6"><span class="pln"></span><span class="pun">}</span></li><li class="L7"><span class="pun">}</span></li></ol></pre><p>正如我们上面所说的那样，我们利用 index 内部存储的一个指针来获取 index 对应的节点。</p><p>最后，<code>BooleanWindow</code> 类非常简单，我们不再详细解释它的代码：</p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><span class="typ">BooleanWindow</span><span class="pun">::</span><span class="typ">BooleanWindow</span><span class="pun">()</span></li><li class="L1"><span class="pun">{</span></li><li class="L2"><span class="pln">    label </span><span class="pun">=</span><span class="pln"></span><span class="kwd">new</span><span class="pln"></span><span class="typ">QLabel</span><span class="pun">(</span><span class="pln">tr</span><span class="pun">(</span><span class="str">&#34;Boolean expression:&#34;</span><span class="pun">));</span></li><li class="L3"><span class="pln">    lineEdit </span><span class="pun">=</span><span class="pln"></span><span class="kwd">new</span><span class="pln"></span><span class="typ">QLineEdit</span><span class="pun">;</span></li><li class="L4"><span class="pln"> </span></li><li class="L5"><span class="pln">    booleanModel </span><span class="pun">=</span><span class="pln"></span><span class="kwd">new</span><span class="pln"></span><span class="typ">BooleanModel</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span></li><li class="L6"><span class="pln"> </span></li><li class="L7"><span class="pln">    treeView </span><span class="pun">=</span><span class="pln"></span><span class="kwd">new</span><span class="pln"></span><span class="typ">QTreeView</span><span class="pun">;</span></li><li class="L8"><span class="pln">    treeView</span><span class="pun">-&gt;</span><span class="pln">setModel</span><span class="pun">(</span><span class="pln">booleanModel</span><span class="pun">);</span></li><li class="L9"><span class="pln"> </span></li><li class="L0"><span class="pln">    connect</span><span class="pun">(</span><span class="pln">lineEdit</span><span class="pun">,</span><span class="pln"> SIGNAL</span><span class="pun">(</span><span class="pln">textChanged</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QString</span><span class="pln"></span><span class="pun">&amp;)),</span></li><li class="L1"><span class="pln"></span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> SLOT</span><span class="pun">(</span><span class="pln">booleanExpressionChanged</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QString</span><span class="pln"></span><span class="pun">&amp;)));</span></li><li class="L2"><span class="pln"> </span></li><li class="L3"><span class="pln"></span><span class="typ">QGridLayout</span><span class="pln"></span><span class="pun">*</span><span class="pln">layout </span><span class="pun">=</span><span class="pln"></span><span class="kwd">new</span><span class="pln"></span><span class="typ">QGridLayout</span><span class="pun">;</span></li><li class="L4"><span class="pln">    layout</span><span class="pun">-&gt;</span><span class="pln">addWidget</span><span class="pun">(</span><span class="pln">label</span><span class="pun">,</span><span class="pln"></span><span class="lit">0</span><span class="pun">,</span><span class="pln"></span><span class="lit">0</span><span class="pun">);</span></li><li class="L5"><span class="pln">    layout</span><span class="pun">-&gt;</span><span class="pln">addWidget</span><span class="pun">(</span><span class="pln">lineEdit</span><span class="pun">,</span><span class="pln"></span><span class="lit">0</span><span class="pun">,</span><span class="pln"></span><span class="lit">1</span><span class="pun">);</span></li><li class="L6"><span class="pln">    layout</span><span class="pun">-&gt;</span><span class="pln">addWidget</span><span class="pun">(</span><span class="pln">treeView</span><span class="pun">,</span><span class="pln"></span><span class="lit">1</span><span class="pun">,</span><span class="pln"></span><span class="lit">0</span><span class="pun">,</span><span class="pln"></span><span class="lit">1</span><span class="pun">,</span><span class="pln"></span><span class="lit">2</span><span class="pun">);</span></li><li class="L7"><span class="pln">    setLayout</span><span class="pun">(</span><span class="pln">layout</span><span class="pun">);</span></li><li class="L8"><span class="pln"> </span></li><li class="L9"><span class="pln">    setWindowTitle</span><span class="pun">(</span><span class="pln">tr</span><span class="pun">(</span><span class="str">&#34;Boolean Parser&#34;</span><span class="pun">));</span></li><li class="L0"><span class="pun">}</span></li><li class="L1"><span class="pln"> </span></li><li class="L2"><span class="kwd">void</span><span class="pln"></span><span class="typ">BooleanWindow</span><span class="pun">::</span><span class="pln">booleanExpressionChanged</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"></span><span class="typ">QString</span><span class="pln"></span><span class="pun">&amp;</span><span class="pln">expr</span><span class="pun">)</span></li><li class="L3"><span class="pun">{</span></li><li class="L4"><span class="pln"></span><span class="typ">BooleanParser</span><span class="pln"> parser</span><span class="pun">;</span></li><li class="L5"><span class="pln"></span><span class="typ">Node</span><span class="pln"></span><span class="pun">*</span><span class="pln">rootNode </span><span class="pun">=</span><span class="pln"> parser</span><span class="pun">.</span><span class="pln">parse</span><span class="pun">(</span><span class="pln">expr</span><span class="pun">);</span></li><li class="L7"><span class="pun">}</span></li></ol></pre><p>这样，我们的布尔表达式树模型已经创建完毕。下面来运行一下看看效果：</p><p>最后，我们附上整个项目的代码：</p><!-- 原文：http://www.devbean.net/2013/05/qt-study-road-2-bool-tree-model/ --></article><div class="row hung-read-link"><div class="col-xs-12 hung-pre" style="display: none"><span class="text-muted">上一篇:</span><a href="#"></a></div><div class="col-xs-12 hung-next" style="display: none"><span class="text-muted">下一篇:</span><a href="#"></a></div></div><div class="bookstack-bars"><ul><li class="visible-xs visible-sm bars-menu bars-menu-hide"><a href="/" title="首页"><i class="fa fa-home"></i></a></li><li class="visible-xs visible-sm bars-menu bars-menu-hide"><a title="下载" href="javascript:" data-toggle="modal" data-target="#ModalDownload"><i class="fa fa-cloud-download"></i></a></li><li class="visible-xs visible-sm bars-menu bars-menu-hide"><a title="分享" href="javascript:" data-toggle="modal" data-target="#ModalShare"><i class="fa fa-share-alt"></i></a></li><li class="visible-xs visible-sm bars-menu bars-menu-hide"><a title="阅读记录" class="showModalHistory" href="/record/2072" rel="nofollow"><i class="fa fa-clock-o"></i></a></li><li class="visible-xs visible-sm bars-menu bars-menu-hide"><a rel="nofollow" href="/bookmark/list/2072" data-bookid="2072" class="showModalBookmark" title="书签"><img src="https://static.sitestack.cn/static/images/icon-bookmark-list.png" alt="书签"></a></li><li class="visible-xs visible-sm bars-menu bars-menu-hide"><a href="/bookmark/" data-docid="114708" rel="nofollow" class="bookmark-action"><span class="bookmark-add "><img src="https://static.sitestack.cn/static/images/icon-bookmark-add.png" alt="添加书签"></span><span class="bookmark-remove hide"><img src="https://static.sitestack.cn/static/images/icon-bookmark-remove.png" alt="移除书签"></span></a></li><li class="book-menu visible-xs visible-sm"><a href="javascript:void(0);" title="菜单"><i class="fa fa-align-justify"></i></a></li><li class="visible-xs visible-sm bars-menu-toggle"><a href="#" title="更多功能"><i class="fa fa-plus-circle"></i><i class="fa fa-minus-circle hide"></i></a></li><li><a href="javascript:;" class="view-backtop"><i class="fa fa-arrow-up" aria-hidden="true"></i></a></li></ul></div></div></div></div><div class="manual-left"><div class="article-search" data-bookid="2072"><form id="searchForm" action="/read/qt-study-road-2/search" method="post"><div class="input-group"><input type="text" name="keyword" placeholder="Search..." autocomplete="off" class="form-control"><span class="input-group-addon input-group-addon-clear"><i class="fa fa-remove"></i></span><span class="input-group-addon"><button type="submit"><i class="fa fa-search"></i></button></span></div></form><div class="pull-right hidden-xs"><i class="fa fa-align-justify"></i></div></div><div class="article-menu"><div class="article-menu-detail "><ul><li id="114658"><a href="/read/qt-study-road-2/ddf84b4ac149953f.md" title="序">序</a></li><li id="114659"><a href="/read/qt-study-road-2/b173882cafb6bb28.md" title="Qt 前言">Qt 前言</a></li><li id="114660"><a href="/read/qt-study-road-2/b9f9e4d7af0e180f.md" title="Hello, world!">Hello, world!</a></li><li id="114661"><a href="/read/qt-study-road-2/668427db58141c25.md" title="信号槽">信号槽</a></li><li id="114662"><a href="/read/qt-study-road-2/53a93ec4b7d255a2.md" title="自定义信号槽">自定义信号槽</a></li><li id="114663"><a href="/read/qt-study-road-2/7dc4239febc2d0a9.md" title="Qt 模块简介">Qt 模块简介</a></li><li id="114664"><a href="/read/qt-study-road-2/598b1d4333151550.md" title="MainWindow 简介">MainWindow 简介</a></li><li id="114665"><a href="/read/qt-study-road-2/81fa0a8cd4d57805.md" title="添加动作">添加动作</a></li><li id="114666"><a href="/read/qt-study-road-2/339f5fe4b2eb46ba.md" title="资源文件">资源文件</a></li><li id="114667"><a href="/read/qt-study-road-2/cd2607d3345cb88a.md" title="对象模型">对象模型</a></li><li id="114668"><a href="/read/qt-study-road-2/ba22b260c9ef023f.md" title="布局管理器">布局管理器</a></li><li id="114669"><a href="/read/qt-study-road-2/802bbd94fd9f44bf.md" title="菜单栏、工具栏和状态栏">菜单栏、工具栏和状态栏</a></li><li id="114670"><a href="/read/qt-study-road-2/ee8e5f4650e3cf35.md" title="对话框简介">对话框简介</a></li><li id="114671"><a href="/read/qt-study-road-2/aa82a08a2d6a25f1.md" title="对话框数据传递">对话框数据传递</a></li><li id="114672"><a href="/read/qt-study-road-2/2fdc659f26d1dce6.md" title="标准对话框 QMessageBox">标准对话框 QMessageBox</a></li><li id="114673"><a href="/read/qt-study-road-2/995f89d87fb8577e.md" title="深入 Qt5 信号槽新语法">深入 Qt5 信号槽新语法</a></li><li id="114674"><a href="/read/qt-study-road-2/6dafeeea556f60e8.md" title="文件对话框">文件对话框</a></li><li id="114675"><a href="/read/qt-study-road-2/4af49a64d116a04f.md" title="事件">事件</a></li><li id="114676"><a href="/read/qt-study-road-2/848ba9c7120ea56a.md" title="事件的接受与忽略">事件的接受与忽略</a></li><li id="114677"><a href="/read/qt-study-road-2/44899e58cba977a2.md" title="event()">event()</a></li><li id="114678"><a href="/read/qt-study-road-2/aa8f65629f82efd8.md" title="事件过滤器">事件过滤器</a></li><li id="114679"><a href="/read/qt-study-road-2/28e6901ddfee8f36.md" title="事件总结">事件总结</a></li><li id="114680"><a href="/read/qt-study-road-2/0b99bc20920205f5.md" title="自定义事件">自定义事件</a></li><li id="114681"><a href="/read/qt-study-road-2/79e1c3eb84a6cbe2.md" title="Qt 绘制系统简介">Qt 绘制系统简介</a></li><li id="114682"><a href="/read/qt-study-road-2/5e8f0b526f338f9c.md" title="画刷和画笔">画刷和画笔</a></li><li id="114683"><a href="/read/qt-study-road-2/072db2deab546a57.md" title="反走样">反走样</a></li><li id="114684"><a href="/read/qt-study-road-2/fedfbcf742b4f392.md" title="渐变">渐变</a></li><li id="114685"><a href="/read/qt-study-road-2/8eccc101fb6cd3f7.md" title="坐标系统">坐标系统</a></li><li id="114686"><a href="/read/qt-study-road-2/0c88a7607f6afd1f.md" title="绘制设备">绘制设备</a></li><li id="114687"><a href="/read/qt-study-road-2/ff2ce57762350d38.md" title="Graphics View Framework">Graphics View Framework</a></li><li id="114688"><a href="/read/qt-study-road-2/434723f60dbe2dab.md" title="贪吃蛇游戏（1）">贪吃蛇游戏（1）</a></li><li id="114689"><a href="/read/qt-study-road-2/306ae8809d208a8c.md" title="贪吃蛇游戏（2）">贪吃蛇游戏（2）</a></li><li id="114690"><a href="/read/qt-study-road-2/c440b957b57ee699.md" title="贪吃蛇游戏（3）">贪吃蛇游戏（3）</a></li><li id="114691"><a href="/read/qt-study-road-2/a0b9720e6d4fb280.md" title="贪吃蛇游戏（4）">贪吃蛇游戏（4）</a></li><li id="114692"><a href="/read/qt-study-road-2/da83aa582cd34d4d.md" title="文件">文件</a></li><li id="114693"><a href="/read/qt-study-road-2/8718d88cc58c6420.md" title="二进制文件读写">二进制文件读写</a></li><li id="114694"><a href="/read/qt-study-road-2/267daa1d29b026f7.md" title="文本文件读写">文本文件读写</a></li><li id="114695"><a href="/read/qt-study-road-2/347d0bb9b218b37a.md" title="存储容器">存储容器</a></li><li id="114696"><a href="/read/qt-study-road-2/3093bfe559a73090.md" title="遍历容器">遍历容器</a></li><li id="114697"><a href="/read/qt-study-road-2/8c3cf33a2df05e85.md" title="隐式数据共享">隐式数据共享</a></li><li id="114698"><a href="/read/qt-study-road-2/83a09393e36d7ef8.md" title="model/view 架构">model/view 架构</a></li><li id="114699"><a href="/read/qt-study-road-2/7859289efd55f27d.md" title="QListWidget、QTreeWidget 和 QTableWidget">QListWidget、QTreeWidget 和 QTableWidget</a></li><li id="114700"><a href="/read/qt-study-road-2/8c4f365fa95992a0.md" title="QStringListModel">QStringListModel</a></li><li id="114701"><a href="/read/qt-study-road-2/37b53b6e77e7af1b.md" title="QFileSystemModel">QFileSystemModel</a></li><li id="114702"><a href="/read/qt-study-road-2/17c5fc8336ec6a88.md" title="模型">模型</a></li><li id="114703"><a href="/read/qt-study-road-2/9efaa1eda2b10483.md" title="视图和委托">视图和委托</a></li><li id="114704"><a href="/read/qt-study-road-2/64bb5d81354205e6.md" title="视图选择">视图选择</a></li><li id="114705"><a href="/read/qt-study-road-2/7693f03b5922e295.md" title="QSortFilterProxyModel">QSortFilterProxyModel</a></li><li id="114706"><a href="/read/qt-study-road-2/a435179e7c80533b.md" title="自定义只读模型">自定义只读模型</a></li><li id="114707"><a href="/read/qt-study-road-2/6b64b6724911ba5d.md" title="自定义可编辑模型">自定义可编辑模型</a></li><li id="114708" class="jstree-open"><a href="/read/qt-study-road-2/7c31ce27fd10f6f5.md" title="布尔表达式树模型" class="jstree-clicked">布尔表达式树模型</a></li><li id="114709"><a href="/read/qt-study-road-2/ce640e75f72f93bb.md" title="使用拖放">使用拖放</a></li><li id="114710"><a href="/read/qt-study-road-2/958c62ce19391250.md" title="自定义拖放数据">自定义拖放数据</a></li><li id="114711"><a href="/read/qt-study-road-2/b4bd6921756df9cc.md" title="剪贴板">剪贴板</a></li><li id="114712"><a href="/read/qt-study-road-2/82f734ec4ee5155e.md" title="数据库操作">数据库操作</a></li><li id="114713"><a href="/read/qt-study-road-2/85d39f416f85222e.md" title="使用模型操作数据库">使用模型操作数据库</a></li><li id="114714"><a href="/read/qt-study-road-2/7517fda20f3cd965.md" title="可视化显示数据库数据">可视化显示数据库数据</a></li><li id="114715"><a href="/read/qt-study-road-2/48fe72e6334dc3ce.md" title="编辑数据库外键">编辑数据库外键</a></li><li id="114716"><a href="/read/qt-study-road-2/a7ca48855a90a6b0.md" title="使用流处理 XML">使用流处理 XML</a></li><li id="114717"><a href="/read/qt-study-road-2/f1543ab950032281.md" title="使用 DOM 处理 XML">使用 DOM 处理 XML</a></li><li id="114718"><a href="/read/qt-study-road-2/b4215e699391233e.md" title="使用 SAX 处理 XML">使用 SAX 处理 XML</a></li><li id="114719"><a href="/read/qt-study-road-2/c454952342246043.md" title="保存 XML">保存 XML</a></li><li id="114720"><a href="/read/qt-study-road-2/db3e435ceb1307fd.md" title="使用 QJson 处理 JSON">使用 QJson 处理 JSON</a></li><li id="114721"><a href="/read/qt-study-road-2/00b893663269f074.md" title="使用 QJsonDocument 处理 JSON">使用 QJsonDocument 处理 JSON</a></li><li id="114722"><a href="/read/qt-study-road-2/753baa2dbeea422a.md" title="访问网络（1）">访问网络（1）</a></li><li id="114723"><a href="/read/qt-study-road-2/bf9e75eef4e9f7f0.md" title="访问网络（2）">访问网络（2）</a></li><li id="114724"><a href="/read/qt-study-road-2/427c8d077d351a6d.md" title="访问网络（3）">访问网络（3）</a></li><li id="114725"><a href="/read/qt-study-road-2/9ab4c3337b2edc68.md" title="访问网络（4）">访问网络（4）</a></li><li id="114726"><a href="/read/qt-study-road-2/28e1af2b4b7b93ee.md" title="进程">进程</a></li><li id="114727"><a href="/read/qt-study-road-2/80d3af86964788b9.md" title="进程间通信">进程间通信</a></li><li id="114728"><a href="/read/qt-study-road-2/39f249c95b840a0f.md" title="线程简介">线程简介</a></li><li id="114729"><a href="/read/qt-study-road-2/7e2a227652bea92a.md" title="线程和事件循环">线程和事件循环</a></li><li id="114730"><a href="/read/qt-study-road-2/012bbea25e667f5a.md" title="Qt 线程相关类">Qt 线程相关类</a></li><li id="114731"><a href="/read/qt-study-road-2/884369e4678bad39.md" title="线程和 QObject">线程和 QObject</a></li><li id="114732"><a href="/read/qt-study-road-2/752ed6d5ed515bcf.md" title="线程总结">线程总结</a></li><li id="114733"><a href="/read/qt-study-road-2/ec6f3afe59aaa8a5.md" title="QML 和 QtQuick 2">QML 和 QtQuick 2</a></li><li id="114734"><a href="/read/qt-study-road-2/ffdc17d45ca95b72.md" title="QML 语法">QML 语法</a></li><li id="114735"><a href="/read/qt-study-road-2/4db49bae4a02a062.md" title="QML 基本元素">QML 基本元素</a></li><li id="114736"><a href="/read/qt-study-road-2/15edfd7a031f980e.md" title="QML 组件">QML 组件</a></li><li id="114737"><a href="/read/qt-study-road-2/845b0afc468e33c4.md" title="定位器">定位器</a></li><li id="114738"><a href="/read/qt-study-road-2/f15a21344cfbabd8.md" title="元素布局">元素布局</a></li><li id="114739"><a href="/read/qt-study-road-2/de2422161acce483.md" title="输入元素">输入元素</a></li><li id="114740"><a href="/read/qt-study-road-2/c0202dc26c11884d.md" title="Qt Quick Controls">Qt Quick Controls</a></li><li id="114741"><a href="/read/qt-study-road-2/d25d025970c604ee.md" title="Repeater">Repeater</a></li><li id="114742"><a href="/read/qt-study-road-2/f2b97a900a353973.md" title="动态视图">动态视图</a></li><li id="114743"><a href="/read/qt-study-road-2/14e9f7cecaa06a9d.md" title="视图代理">视图代理</a></li><li id="114744"><a href="/read/qt-study-road-2/340ee79fddc2d44f.md" title="模型-视图高级技术">模型-视图高级技术</a></li><li id="114745"><a href="/read/qt-study-road-2/01ab6cd4ed7ab721.md" title="Canvas">Canvas</a></li><li id="114746"><a href="/read/qt-study-road-2/51191bb219b7a737.md" title="Canvas（续）">Canvas（续）</a></li><li id="114747"><a href="/read/qt-study-road-2/de0c9d561eb0f5eb.md" title="粒子系统">粒子系统</a></li><li id="114748"><a href="/read/qt-study-road-2/0f8f132e1aba5ff2.md" title="粒子系统（续）">粒子系统（续）</a></li></ul></div><div class="search-result"><div class="search-empty" style="display: block;"><i class="fa fa-search-plus" aria-hidden="true"></i><b class="text">暂无相关搜索结果！</b></div><ul class="search-list" id="searchList"></ul></div></div><div class="m-copyright"><p>
                        本文档使用 <a href="//www.bookstack.cn" style="color: #0e8c8c;font-weight: bold" target="_blank">BookStack</a> 构建
                    </p></div></div><div class="manual-progress"><b class="progress-bar"></b></div></div><div class="manual-mask"></div></div><span class="article-toggle tooltips" title="展开/收起文章目录"><img alt="展开/收起文章目录" src="https://static.sitestack.cn/static/images/toggle.png"/></span><div id="menu-hidden" style="display: none;"><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?227e05b01b8f7eefb29a75df28f53840";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277690469'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/stat.php%3Fid%3D1277690469' type='text/javascript'%3E%3C/script%3E"));</script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-166942584-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-166942584-1');
</script></div><div class="modal fade" id="ModalShare" tabindex="-1" role="dialog" aria-labelledby="ModalShareLabel" aria-hidden="true"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="ModalShareLabel">分享，让知识传承更久远</h4></div><div class="modal-body"><div class="bdsharebuttonbox"><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a><a href="#" class="bds_bdysc" data-cmd="bdysc" title="分享到百度云收藏"></a><a href="#" class="bds_kaixin001" data-cmd="kaixin001" title="分享到开心网"></a><a href="#" class="bds_bdxc" data-cmd="bdxc" title="分享到百度相册"></a><a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a><a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a><a href="#" class="bds_tqf" data-cmd="tqf" title="分享到腾讯朋友"></a><a href="#" class="bds_thx" data-cmd="thx" title="分享到和讯微博"></a><a href="#" class="bds_bdhome" data-cmd="bdhome" title="分享到百度新首页"></a><a href="#" class="bds_meilishuo" data-cmd="meilishuo" title="分享到美丽说"></a><a href="#" class="bds_ibaidu" data-cmd="ibaidu" title="分享到百度中心"></a><a href="#" class="bds_mogujie" data-cmd="mogujie" title="分享到蘑菇街"></a><a href="#" class="bds_diandian" data-cmd="diandian" title="分享到点点网"></a><a href="#" class="bds_huaban" data-cmd="huaban" title="分享到花瓣"></a><a href="#" class="bds_hx" data-cmd="hx" title="分享到和讯"></a><a href="#" class="bds_duitang" data-cmd="duitang" title="分享到堆糖"></a><a href="#" class="bds_fx" data-cmd="fx" title="分享到飞信"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_sdo" data-cmd="sdo" title="分享到麦库记事"></a><a href="#" class="bds_qingbiji" data-cmd="qingbiji" title="分享到轻笔记"></a><a href="#" class="bds_people" data-cmd="people" title="分享到人民微博"></a><a href="#" class="bds_xinhua" data-cmd="xinhua" title="分享到新华微博"></a><a href="#" class="bds_mail" data-cmd="mail" title="分享到邮件分享"></a><a href="#" class="bds_isohu" data-cmd="isohu" title="分享到我的搜狐"></a><a href="#" class="bds_yaolan" data-cmd="yaolan" title="分享到摇篮空间"></a><a href="#" class="bds_wealink" data-cmd="wealink" title="分享到若邻网"></a><a href="#" class="bds_iguba" data-cmd="iguba" title="分享到股吧"></a><a href="#" class="bds_ty" data-cmd="ty" title="分享到天涯社区"></a><a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a><a href="#" class="bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a><a href="#" class="bds_h163" data-cmd="h163" title="分享到网易热"></a><a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a><a href="#" class="bds_evernotecn" data-cmd="evernotecn" title="分享到印象笔记"></a><a href="#" class="bds_copy" data-cmd="copy" title="分享到复制网址"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='https:\/\/static.sitestack.cn/static/api/js/share.js'];</script></div><div class="modal-footer"><button type="button" class="btn btn-danger" data-dismiss="modal">取消分享</button></div></div></div></div><div class="modal fade" id="ModalQRcode" tabindex="-1" role="dialog" aria-labelledby="ModalShareLabel" aria-hidden="true"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="ModalShareLabel">文章二维码</h4></div><div class="modal-body"><div id="qrcode" style="width: 256px;height: 256px;margin: 0px auto;margin-bottom: 15px;"></div><div class="help-block text-center">手机扫一扫，轻松掌上读</div></div><div class="modal-footer"><button type="button" class="btn btn-danger" data-dismiss="modal">关闭</button></div></div></div></div><div class="modal fade" id="ModalDownload" tabindex="-1" role="dialog" aria-labelledby="ModalDownloadLabel" aria-hidden="true"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="ModalDownloadLabel">文档下载</h4></div><div class="modal-body clearfix"><div class="help-block"><div class="row"><div class="col-sm-6 col-xs-6 text-center"><div class="help-block">
                                    你与大神的距离，只差一个APP
                                </div><img src="https://static.bookstack.cn/projects/help/15d7e8169208fad1.png" style="width:100%;max-width: 133px;" alt="APP下载"></div><div class="col-sm-6 col-xs-6"><div class="help-block">请下载您需要的格式的文档，随时随地，享受汲取知识的乐趣！</div><a href="/export/qt-study-road-2?output=pdf" class="btn btn-default btn-filedown btn-block"><i class="fa fa-cloud-download"></i> PDF<span class="hidden-xs">文档</span></a><a href="/export/qt-study-road-2?output=epub" class="btn btn-default btn-filedown btn-block"><i class="fa fa-cloud-download"></i> EPUB<span class="hidden-xs">文档</span></a><a href="/export/qt-study-road-2?output=mobi" class="btn btn-default btn-filedown btn-block"><i class="fa fa-cloud-download"></i> MOBI<span class="hidden-xs">文档</span></a></div></div></div><div class="help-block"><strong>温馨提示</strong><span class="text-danger">每天每在网站阅读学习一分钟时长可下载一本电子书，每天连续签到可增加阅读时长</span></div></div><div class="modal-footer"><button type="button" class="btn btn-danger" data-dismiss="modal">关闭窗口</button></div></div></div></div><div class="modal fade" id="ModalBookChat" tabindex="-1" role="dialog" aria-labelledby="ModalBookChatLabel" aria-hidden="true"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="ModalBookChatLabel">微信小程序阅读</h4></div><div class="modal-body text-center"><img src="https://static.sitestack.cn/projects/qt-study-road-2/wxacode.jpeg" style="margin: 15px auto;" class="img-responsive" alt="BookChat 微信小程序阅读"><div class="help-block">微信扫一扫，知识掌上学</div></div><div class="modal-footer"><button type="button" class="btn btn-danger" data-dismiss="modal">关闭窗口</button></div></div></div></div><div class="modal fade" id="ModalBookmark" tabindex="-1" role="dialog" aria-labelledby="ModalBookmarkLabel" aria-hidden="true"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="ModalBookmarkLabel">书签列表</h4></div><div class="modal-body"><ul></ul></div><div class="modal-footer"><button type="button" class="btn btn-danger" data-dismiss="modal">关闭</button></div></div></div></div><div class="modal fade" id="ModalHistory" tabindex="-1" role="dialog" aria-labelledby="ModalBookmarkLabel" aria-hidden="true"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="ModalBookmarkLabel">阅读记录</h4></div><div class="modal-body"><div class="help-block progress-block">
                    阅读进度:  <span class="text-success">0.00%</span> ( <span class="text-muted">0/0</span> )
                    <a href="#" class="reset-history pull-right"><i class="fa fa-refresh"></i> 重置阅读进度</a></div><div class="progress progress-striped active"><div class="progress-bar progress-bar-success" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 0%;"><span class="sr-only"></span></div></div><hr><ul></ul></div><div class="modal-footer"><button type="button" class="btn btn-danger" data-dismiss="modal">关闭</button></div></div></div></div><div class="bookstack-viewer"></div><script src="https://static.sitestack.cn/static/jquery/1.12.4/jquery.min.js" type="text/javascript"></script><script src="https://static.sitestack.cn/static/bootstrap/js/bootstrap.min.js" type="text/javascript"></script><script type="text/javascript" src="https://static.sitestack.cn/static/nprogress/nprogress.js"></script><script type="text/javascript" src="https://static.sitestack.cn/static/highlight/highlight.js"></script><script type="text/javascript" src="https://static.sitestack.cn/static/highlight/highlightjs-line-numbers.min.js"></script><script type="text/javascript" src="https://static.sitestack.cn/static/js/jquery.highlight.js"></script><script type="text/javascript" src="https://static.sitestack.cn/static/js/toast.script.js"></script><script type="text/javascript" src="https://static.sitestack.cn/static/js/jquery.qrcode.min.js"></script><script type="text/javascript" src="https://static.sitestack.cn/static/js/clipboard.min.js"></script><script type="text/javascript" src="https://static.sitestack.cn/static/katex/katex.min.js"></script><script src="https://static.sitestack.cn/static/editor.md/lib/marked.min.js" type="text/javascript"></script><script src="https://static.sitestack.cn/static/mind-map/kity.min.js" type="text/javascript"></script><script src="https://static.sitestack.cn/static/mind-map/kityminder.core.min.js" type="text/javascript"></script><script src="https://static.sitestack.cn/static/mind-map/mindmap.min.js" type="text/javascript"></script><script type="text/javascript" src="https://static.sitestack.cn/static/js/bookstack.js?version=v2.11.beta1"></script><script type="text/javascript" src="https://static.sitestack.cn/static/js/main.js?version=v2.11.beta1"></script><script type="text/javascript">
    'use strict';
$(function () {

    var keywords="";
    if (keywords){
        var wds =keywords.split(","),l=wds.length;
        for (var i = 0; i < l; i++) {
            $(".markdown-body").highlight(wds[i].trim());
        }
    }

    $("#searchList").on("click","a",function () {
        var id = $(this).attr("data-id");
        var url = "\/read\/qt-study-road-2\/" + id;
        var _this=$(this);
        _this.parent("li").siblings().find("a").removeClass("active");
        _this.addClass("active");
        load_doc(url,_this.attr("data-wd"));
    });
    
    $(".markdown-body").on("click",".btn-ilink",function (e) {
        redirect($(this).parents("a").attr("href"));
    })
    $(".markdown-body").on("click","a",function (e) {
        e.preventDefault();
        var _this = $(this);
        if(_this.find("img").length == 0){
            redirect(_this.attr("href"))
        }
    });

    function redirect(href){
        var hrefLower=href.toLowerCase();
        if(hrefLower.indexOf("http://")==0 || hrefLower.indexOf("https://")==0 ){
            window.open(href);
        }else{
            location.href=href;
        }
    }

    show_copy_btn();
    initLinkWithImage();

    $(".tooltips").tooltip();
    $("#qrcode").qrcode(location.href);

    var clipboard = new ClipboardJS('.btn-copy',{
        
        target: function(trigger) {
            return trigger.nextElementSibling;
        }
    });

    clipboard.on('success', function(e) {
        console.info('Copy Content：', e.text);
        alertTips("success","代码复制成功",3000,"");
    });

    clipboard.on('error', function(e) {
        console.log("Copy Error：",e);
    });

    $(".book-menu").click(function () {
        $(".slidebar").trigger("click");
    });

    $(".article-toggle").click(function () {
        if($("body").hasClass("article-menu-hide")){
            $("body").removeClass("article-menu-hide");
        }else{
            $("body").addClass("article-menu-hide");
        }
    });
    $(".collapse-menu .collapse-node span").click(function (e) {
        if($(this).parent().hasClass("collapse-hide")){
            $(this).parent().removeClass("collapse-hide")
        }else {
            $(this).parent().addClass("collapse-hide")
        }
    })
});
</script></body></html>